import pygame # импортируем библиотеку pygame
import sys # импортируем библиотеку sys для обработки системных команд
import random # импортируем библиотеку random для рандома

def overlap(x,y,w,h,vx,vy,vw,vh): # создаем функцию(небольшую подпрограмму) с именем overlap которая принимает следующие аргументы: x,y,w,h,vx,vy,vw,vh
    x2=x+w # переменная x2 равна x координате игрока плюс длина игрока
    y2=y+h # переменная y2 равна y координате игрока плюс ширина(высота) игрока
    vx2=vx+vw # переменная vx2 равна x координате i(каждого) врага плюс длине этого же врага
    vy2=vy+vh # переменная vy2 равна y координате i(каждого) врага плюс ширине(высоте) этого же врага
    r = (vx<=x<=vx2 or x<=vx<=x2) and (vy<=y<=vy2 or y<=vy<=y2) # сравниваем полученные значения и...
    return r # возвращаем его

def space_wait(): # создаем функцию с именем space_wait
    wait=True # присваем переменной wait значение True (это означает что мы ждем нажатие клавиши)
    while wait: # пока значение переменной wait равно True...
        for event in pygame.event.get(): # проверяем все системные события игры 
            if event.type == pygame.QUIT: # если окно закрылось, то...
                wait = False # сбрасываем флажок в значение ЛОЖЬ для выхода из цикла
                pygame.quit() # останавливаем игровой движок
                sys.exit() # закрываем окно с экраном игры
        keys = pygame.key.get_pressed() # запрашиваем состояние клавиатуры
        if keys[pygame.K_SPACE]: # если в keys зафиксировано нажатие стрелки вправо
            wait = False # брасываем переменную-флажок в значение ЛОЖЬ для выхода

def game_begin(): # функция инициализации игрока и врагов
    global player_x # указываем что переменная player_x является глобальной, чтобы основная программа могла с ней обратится
    player_x = 15 # задаем начальную координату x для рыбки-героя
    global player_y # указываем что переменная player_y является глобальной, чтобы основная программа могла с ней обратится
    player_y = 30 # задаем начальную координату y для рыбки-героя
    global player_size # указываем что переменная player_size является глобальной, чтобы основная программа могла с ней обратится
    player_size=30 # задаем высоту рыбки-героя в пикселях
    global player_left # указываем что переменная player_left является глобальной, чтобы основная программа могла с ней обратится
    player_left=False # задаем переменную, которая указывает, что герой движется налево
    for i in range(enemy_n):
        enemy_x[i]=random.randint(0,s_width) # задаем случайную координату x для врага
        enemy_y[i]=random.randint(0,s_high) # задаем случайную координату y для врага
        enemy_tick[i]=random.randint(0,10) # задаем случайное начальное значение тиков 
        enemy_speed[i]=random.randint(-3,3) # задаем случайную скорость врага
        enemy_size[i]=random.randint(15,60) # задачем случайный размер врага
    global fish_count # указываем что переменная fish_count является глобальной, чтобы основная программа могла с ней обратится
    fish_count=0 # задаем переменную-счетчик съеденных рыбок

# ***************** Начало игры *****************
pygame.init() # инициализируем движок
screen = pygame.display.set_mode((1000, 650)) # открываем окно на дисплее
clock = pygame.time.Clock() # создаем системный объект clock, обратимся к нему позднее для задержки игры
running = True # создаем логическую переменную-флажок, означающую, что игра выполняется
s_width=1000 # задаем перменную ширины игрового окна
s_high=600 # задаем переменную высоты игрового окна
b_main=True # необходимо для смены фона (если True то фон один и если False то другой)
b_tick=50 # таймер(счетчик тиков) по истечению которого сменится фон

background_pic=pygame.image.load("Scene_A.png") # подгружаем картинку фона
background_pic2=pygame.image.load("Scene_B.png") # альтернативный фон(служит для анимации)
restart_pic = pygame.image.load("BtnRestart.png") # подгружаем картинку перезапуска (кнопка Рестарт)
start_pic = pygame.image.load("BtnPlay.png") # подгружаем картинку начала (кнопка Старт)
player_pic = pygame.image.load("Fish05_A.png") # подгружаем картинку рыбки
bubble_pic = pygame.image.load("Bubble.png") # подгружаем картинку пузырька
enemy_pic = pygame.image.load("Fish02_A.png") # подгружаем картинку вражеской рыбки
enemy_pic2 = pygame.image.load("Fish02_B.png") # подгружаем альтернативную картинку вражеской рыбки
enemy1_pic = pygame.image.load("Fish03_A.png") # подгружаем картинку вражеской рыбке №1
enemy2_pic = pygame.image.load("Fish02_A.png") # подгружаем картинку вражеской рыбке №2
count_pic = pygame.image.load("FishCounter.png") # подгружаем съеденных рыбок (счетчик съеденных рыб)
count_pic = pygame.transform.scale(count_pic, (40,40)) # уменьшаем картинку счетчика

bubble_n = 20 # задаем количество пузырьков на поле
bubble_x = [0]*bubble_n # заполняем массив из x координат нулями для пузырьков
bubble_y = [0]*bubble_n # заполняем массив из y координат нулями для пузырьков
bubble_size = [0]*bubble_n # заполняем массив начальными размерами пузырей
for i in range(bubble_n): # для каждого пузыря выполняем следующие команды:
    bubble_x[i] = random.randint(0, s_width) # каждому пузырю присваиваем случайное значение x координаты из диапазона от нуля до ширины экрана
    bubble_y[i] = random.randint(s_high, s_high*2) # каждому пузырю присваиваем случайное значение y координаты из диапазона от высоты экрана до высоты экрана умноженного на 2
    bubble_size[i] = random.randint(10, 32) # каждому пузырю присваиваем случайный размер из диапазона от 10 до 32

enemy_n=20 # задаем количество вражеских рыб на поле
enemy_x=[0]*enemy_n # заполняем массив из x координат нулями для вражеских рыб
enemy_y=[0]*enemy_n # заполняем массив из y координат нулями для вражеских рыб
enemy_size=[50]*enemy_n # заполняем массив начальными размерами вражеских рыб
enemy_speed=[2]*enemy_n # заполняем массив начальной скоростью вражеских рыб
enemy_main=[True]*enemy_n # заполняем массив enemy_main значением True для каждой рыбки (служит для поворота рыбки)
enemy_tick=[0]*enemy_n # заполняем массив нулями для таймера смены анимации вражеской рыбки

enemy1_x = 200 # задаем начальное положение для x координаты вражеской рыбке №1
enemy1_y = 200 # задаем начальное положение для y координаты вражеской рыбке №1
enemy1_size = 80 # задаем начальный размер вражеской рыбке №1
enemy1_speed = 1 # задаем начальную скорость вражеской рыбке №1
enemy2_x = 450 # задаем начальное положение для x координаты вражеской рыбке №2
enemy2_y = 300 # задаем начальное положение для y координаты вражеской рыбке №2
enemy2_size = 50 # задаем начальный размер вражеской рыбке №2
enemy2_speed = 2 # задаем начальную скорость вражеской рыбке №2

pygame.font.init() # инициализация шрифтов
myfont = pygame.font.SysFont('Comic Sans MS', 30) # настройка шрифта
screen.blit(background_pic,(0,0)) # выводим аквариум
screen.blit(start_pic,(420,250)) # выводим картинку play
pygame.display.flip() # обновляем экран
space_wait() # ждем пробел
lifes=3 # задаем количество жизней
game_begin() # инициализируем игрока и врагов

# ***************** Основной цикл игры *****************
# Все ниже 'while running' будет повторяться бесконечно, пока не закроете окно (т.е. когда running станет = False)
while running:
    for event in pygame.event.get(): # проверяем все системные события игры в списке pygame.event.get()
        if event.type == pygame.QUIT: # если нашли событие, связаное с закрытием окна, то...
            running = False # сбрасываем переменную-флажок в значение ЛОЖЬ для выхода из основного цикла
        
    keys = pygame.key.get_pressed() # запрашиваем состояние клавиатуры и запоминаем в keys
    if keys[pygame.K_RIGHT]: # если в keys зафиксировано нажатие стрелки вправо
        player_x = player_x + 4 # увеличиваем координату x рыбки
        player_left=False # указываем что рыбка НЕ повернута влево
    if keys[pygame.K_LEFT]: # если в keys зафиксировано нажатие стрелки влево
        player_x = player_x - 4 # уменьшаем координату x рыбки
        player_left=True # указываем что рыбка повернута влево
    if keys[pygame.K_DOWN]: # если в keys зафиксировано нажатие стрелки вниз
        player_y = player_y + 4 # увеличиваем координату y рыбки
    if keys[pygame.K_UP]: # если в keys зафиксировано нажатие стрелки вверх
        player_y = player_y - 4 # уменьшаем координату y рыбки
#    if keys[pygame.K_SPACE]: # если в keys зафиксировано нажатие пробела
#        player_size = player_size + 1 # увеличиваем рыбку на 1

    if b_main: # если флажок основной картинки равен True
        screen.blit(background_pic,(0,0)) # выводим на экран основую картинку фона
    else:
        screen.blit(background_pic2,(0,0)) # выводим на экран вторую картинку фона
       
    player_pic_small = pygame.transform.scale(player_pic,(int(player_size * 1),player_size)) # делаем переменную для картинки игрока со следующими размерами: по ширине = значение переменной player_size, а по длине значение переменной player_size умноженной на 1.25 (это нам надо для того чтобы рыбка отображалась красивше и не сплюснутой)
    if player_left: # если значение переменной player_left равно True(т.е если рыбка повернута влево), то...
        player_pic_small = pygame.transform.flip(player_pic_small,True,False) # отзеркаливаем рыбку
    screen.blit(player_pic_small,(player_x,player_y)) # выводим на определенные координаты(x, y) рыбку игрока
    textsurface = myfont.render(str(lifes), False, (0, 0, 0)) # формируем картинку с цифрой жизней
    screen.blit(textsurface,(player_x-15,player_y)) # выводим картинку с цифрой жизней

    enemy1_pic_small = pygame.transform.scale(enemy1_pic,(int(enemy1_size * 1.25),enemy1_size)) #делаем переменную для картинки врага номер 1 со следующими размерами: по ширине = значение переменной enemy1_size, а по длине значение переменной enemy1_size умноженной на 1.25 (это нам надо для того чтобы рыбка отображалась красивше и не сплюснутой)
    screen.blit(enemy1_pic_small,(enemy1_x,enemy1_y)) # выводим на определенные координаты рыбку врага номер 1 
    enemy1_x = enemy1_x + enemy1_speed #сдвигаем рыбку по х координате по формуле текущее местоположение по х плюс скорость этой рыбки
    enemy2_pic_small = pygame.transform.scale(enemy2_pic,(int(enemy2_size * 1.25),enemy2_size)) # #делаем переменную для картинки врага номер 2 со следующими размерами: по ширине = значение переменной enemy2_size, а по длине значение переменной enemy2_size умноженной на 1.25 (это нам надо для того чтобы рыбка отображалась красивше и не сплюснутой)
    screen.blit(enemy2_pic_small,(enemy2_x,enemy2_y)) ## выводим на определенные координаты рыбку врага номер 2
    enemy2_x = enemy2_x + enemy2_speed #сдвигаем рыбку по х координате по формуле текущее местоположение по х плюс скорость этой рыбки
    
    for i in range(enemy_n): # для каждого врага выполняем команды
        enemy_tick[i]=random.randint(0,10) # для каждой рыбки задаем рандомное значение тиков от 0 до 10
        if overlap(player_x, player_y, int(player_size * 1.25), player_size, enemy_x[i], enemy_y[i], int(enemy_size[i] * 1.25), enemy_size[i]): # если значение функции(подпрограммы) равно True, то...
            if player_size>enemy_size[i]: # если размер игрока больше чем размер врага, то...
                player_size += 2 # увеличиваем размер героя
                enemy_x[i] = -200 # прячем врага за левую границу экрана
#                enemy_speed[i]=2 # задаем положительную скорость движения
                fish_count += 1 # увеличиваем количество съеденных рыбок   
            else: # иначе... (если враг больше игрока)
                enemy_size[i] +=10 # увеличиваем размер врага
                player_x = 15 # задаем начальную х-координату героя
                player_y = 30 # задаем начальную y-координату героя
                player_size=30 # задаем начальный размер героя
                player_left=False # указываем, что герой смотрит направо
                lifes=lifes-1 # уменьшаем счетчик жизней на единицу
                if lifes==0: # если счетчик жизней равен нулю, то...
                    screen.blit(restart_pic,(400,250)) # выводим картинку перезапуска
                    pygame.display.flip() # обновляем экран
                    space_wait() # ждем пробел
                    game_begin() # инициализируем игрока и врагов
                    lifes=3 # возвращаем количество жизней
        if fish_count == 10: # если количество убитых врагов равно 10, то...
            enemy_speed[i] = random.randint(3, 5) # каждой рыбе присваиваем новогое значение скорости
        elif fish_count == 25: # иначе если убитых врагов равно 25, то...
            enemy_speed[i] = random.randint(6, 15) # каждой рыбе присваиваем новогое значение скорости
        elif fish_count == 50: # иначе если убитых врагов равно 50, то...
            enemy_speed[i] = random.randint(15, 25) # каждой рыбе присваиваем новогое значение скорости
        enemy_x[i] = enemy_x[i] + enemy_speed[i] # увеличиваем координату x на величину скорости
        if enemy_x[i]>s_width or enemy_x[i]<-200: # если вражеская рыбка за пределами экрана, то...
            enemy_speed[i] = - enemy_speed[i] # меняем знак скорости на отрицательный
        enemy_tick[i]=enemy_tick[i]-1 # уменьшаем кол-во тиков врага на 1
        if enemy_tick[i]==0: # если количество тиков врага достигло нуля, то...
            enemy_tick[i] = 10 # даем врагу 10 тиков
            enemy_main[i] = not enemy_main[i] # меняем значение переменной enemy_main на противоположный для i врага
        if enemy_main[i]: # если значение enemy_main для i врага равно True, то...
            enemy_pic_small = pygame.transform.scale(enemy_pic,(int(enemy_size[i] * 1.25),enemy_size[i])) # показывается основная картинка рыбки
        else: # иначе... (если enemy_main равен False)
            enemy_pic_small = pygame.transform.scale(enemy_pic2,(int(enemy_size[i] * 1.25),enemy_size[i])) # показывается альтернативная картинка рыбки
        if enemy_speed[i]<0: # если скорость отрицательная, значит рыбка плывет налево, тогда...
            enemy_pic_small = pygame.transform.flip(enemy_pic_small,True,False) # зеркально разворачиваем картинку вражеской рыбки
        screen.blit(enemy_pic_small,(enemy_x[i],enemy_y[i])) # выводим на экран врага

    for i in range(bubble_n): # для каждого пузыря выполняем команды  
        bubble_y[i]=bubble_y[i]-2 # уменьшаем y координату на 2
        if bubble_y[i]<0: # если y координата пузыря меньше нуля, то...
            bubble_y[i]=random.randint(s_high, s_high*2) # присваиваем случайное значение y координаты из диапазона от высоты экрана до высоты экрана умноженного на 2
        bubble_pic_small=pygame.transform.scale(bubble_pic,(bubble_size[i],bubble_size[i])) # делаем переменную для картинки пузыря со следующими размерами: по ширине = значение переменной bubble_size определенного пузыря, а по длине значение переменной bubble_size этого же пузыря
        screen.blit(bubble_pic_small,(bubble_x[i],bubble_y[i])) # выводим на определенные координаты пузырь

    b_tick=b_tick-1 # уменьшаем счетчик тиков фона на 1
    if b_tick==0: # если счетчик тиков уменьшился до нуля, то...
        b_tick=50 # возвращаем счетчику исходное значение
        b_main = not b_main # инвертируем флажок основной картинки

    screen.blit(count_pic,(s_width-60,10)) # выводим картинку съеденной рыбки
    textsurface = myfont.render(str(fish_count), False, (0, 0, 0)) # формируем картинку с цифрой жизней
    screen.blit(textsurface,(s_width-80,10)) # выводим картинку с цифрой жизней

    pygame.display.flip() # обновляем окно дисплея, выводим в него экран с изменениями
    clock.tick(50) # делаем задержку, обновление экрана происходит на быстрее 50 раз в секунду

# ***************** Завершение игры (после выхода из основного цикла) *****************
print("The game has closed") # уведомляем игроков о завершении игры
pygame.quit() # останавливаем игровой движок
sys.exit() # закрываем окно с экраном игры